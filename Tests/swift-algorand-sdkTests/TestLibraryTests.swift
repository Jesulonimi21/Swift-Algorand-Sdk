//import XCTest
//@testable import TestLibrary
//
//final class TestLibraryTests: XCTestCase {
//    func testExample() throws {
//        // This is an example of a functional test case.
//        // Use XCTAssert and related functions to verify your tests produce the correct
//        // results.
//  
//        
//        
//        var _ = try TL()
//        XCTAssertEqual(TestLibrary().text, "Hello, World!")
//        
//    }
//
//    static var allTests = [
//        ("testExample", testExample),
//    ]
//    
////
////    func testLogic(){
////        var lo = Logic()
////          var ch = lo.Ch(12220,12229,1330);
////          print(ch)
////          var maj=lo.Maj(12220,12229,1330);
////          print(maj)
////      var rotat=lo.rotate(12220,12229)
////          print(rotat)
////          var sgma=lo.Sigma0(12220)
////          print(sgma)
////          var sgma1=lo.Sigma1(12220)
////          print(sgma1)
////
////          var _sgma1=lo._Sigma1(12220)
////          print(_sgma1)
////          var _sgma=lo._Sigma0(12220)
////          print(_sgma)
////
////          var byteValue:[Int8]=[97, 55, -6, -123, -107, 104, -126, -122, 48, 41, 27, -74, 44, 123, -126, -63, -93, -107, 56, 104, -75, 95, 116, -34, 103, -34, -14, -41, -74, 103, -33, 46]
////          var paddedByte=lo.pad(byteValue)
////          for i in 0..<paddedByte.count{
////              print(paddedByte[i])
////          }
////          print("      \(paddedByte.count)")
////
////          var arrTolong = lo.arrToLong(byteValue,10)
////          print(arrTolong)
////
////          print("==============================================")
////          var toBlockVal=lo.toBlocks(paddedByte)
////          for i in 0..<toBlockVal.count{
////              print(toBlockVal[i].count)
////              for j in  0..<toBlockVal[i].count{
////                  print(toBlockVal[i][j])
////              }
////          }
////          print(toBlockVal.count)
////
////          print("Message execution starts ============")
////          var toMessageValue=lo.Message(toBlockVal)
////          for i in 0..<toMessageValue.count{
////              print(toMessageValue[i].count)
////              for j in  0..<toMessageValue[i].count{
////                  print(toMessageValue[i][j])
////              }
////          }
////          print(toMessageValue.count)
////
////
////    }
//    
//    
//    
//    
//}
